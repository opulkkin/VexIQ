#pragma config(StandardModel, "Autobot IQ")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Olli Pulkkinen 19.4.2016

// Muunneltu versio arcade control -ohjuksesta. Tavallisella arcade control ohjelmalla voidaan
// ajaa esim. suoraan eteenpain vain puolella teholla ja kaantya paikallaan vain puolella teholla
// Muunneltua arcade control -ohjausta suunnitellessa oli kolme paatavoitetta:

//  1. Suoraan eteenpain ja taaksepain voidaan ajaa taydella teholla
//  2. Paikallaan voidaan kaantya s.e. moottorit pyorivat taydella teholla eri suuntiin.
//  3. Ohjaaminen on muuten melko samanlaista kuin tavallisessa arcade control -ohjauksessa

// Tama ohjelma tayttaa nama tavoitteet. Itse asiassa hammastyin kun huomasin, etta jos tata ohjelmaa kayttaa s.e.
// ajetaan pelkastaan vasemmalla tai oikealla sauvalla, niin ohjaus toimii lahes identtisesti vexIQ:n valmiiksi
// toteutetun RC-ohjauksen kanssa!



// Jos getJoystickValue:n antama arvo ei eroa nollasta PYSAYTYSRAJAa enempaa, niin asetetaan moottorit seis.
// Tama siksi etta joskus robotti jai liikkumaan ensimmaisessa ohjelmaversiossa vaikka
// ohjausssauvat loysattiin.
// Tamantyyppinen ratkaisu on tehty myos natural language funktiossa arcadecontrol.


#define PYSAYTYSRAJA 12     // Teksti PYSAYTYSRAJA korvautuu sen jalkeisella tekstilla koodissa.



// Seuraavassa vakiomakrot joiden avulla valitaan mitka kanavat ovat kaytossa ohjaamisessa:

// Jos halutaan kahden sauvan ohjaus(vasemmalla ohjataan eteen/taakse oikealla kaannellan), niin otetaan
// kayttoon seuraavat kaksi rivia:

#define KANAVAETEENJATAAKSE ChA

#define KANAVAOIKEALLEJAVASEMMALLE ChC


// Jos halutaan pelkastaan oikean sauvan ohjaus, niin otetaan kayttoon seuraavat kaksi rivia:

// #define KANAVAETEENJATAAKSE ChD

// #define KANAVAOIKEALLEJAVASEMMALLE ChC


// Jos halutaan pelkastaan vasemman sauvan ohjaus, niin otetaan kayttoon seuraavat kaksi rivia:

// #define KANAVAETEENJATAAKSE ChA

// #define KANAVAOIKEALLEJAVASEMMALLE ChB



// Jos jostain syysta haluttaisiin viela kahden sauvan ohjaus, jossa oikealla sauvalla ajetaan eteen/taakse ja
// vasemmalla kaannellaan, niin se onnistuu ottamalla kaksi seuraavaa rivia kayttoon:

// #define KANAVAETEENJATAAKSE ChD

// #define KANAVAOIKEALLEJAVASEMMALLE ChB




// Seuraavassa esitellaan main-funktiossa kaytettava funktio, toteutus on main-funktion jalkeen.

void asetaMoottorienNopeudet(short channelEteenTaakse, short channelOikealleVasemmalle);


task main()
{

  setMotorBrakeMode(leftMotor, motorCoast);     // Robottia on helpompi siirreella lykkaamalla
  setMotorBrakeMode(rightMotor, motorCoast);    // talla asetuksella


  short kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema;


  while(true)     // Ikuinen silmukka
	{

	  kanavaEteenTaakseLukema = getJoystickValue(KANAVAETEENJATAAKSE);

  	kanavaOikealleVasemmalleLukema = getJoystickValue(KANAVAOIKEALLEJAVASEMMALLE);


	  // Jos vahintaan toselta kanavalta tuleva getJoystickValue on itseisarvoltaan PYSAYTYSRAJAa suurempi
	  // niin talloin robotin moottoreille annetaan nopeudet asetaMoottorienNopeudet-funktion mukaisesti.

	  if(abs(kanavaEteenTaakseLukema) > PYSAYTYSRAJA || abs(kanavaOikealleVasemmalleLukema) > PYSAYTYSRAJA){

	    asetaMoottorienNopeudet(kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema);

		}else{

			setMotorSpeed(leftMotor, 0);    // Jos kumpikaan getJoystickValue arvoista ei ole itseisarvoltaan pysaytysrajaa suurempi
																			// niin pysaytetaan.
			setMotorSpeed(rightMotor, 0);

			displayTextLine(1, "%s%d", "Vasen moottori: ", 0);    // Testivaiheessa oli hyva nahda moottorien
  																													// nopeudet naytolla. Muutenkin ihan kiva.
	    displayTextLine(3, "%s%d", "Oikea moottori: ", 0);
	  }

	}

}


// Tassa on asetaMoottorienNopeudet-funktion toteutus.

void asetaMoottorienNopeudet(short channelEteenTaakse, short channelOikealleVasemmalle){

  short vasenNopeus = 0;

  short oikeaNopeus = 0;

  if(channelEteenTaakse >= 0){

    if(channelOikealleVasemmalle >= 0){

      vasenNopeus = sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(vasenNopeus > 100)   // Tata ei olisi pakko tehda koska yli sadan menevat nopeudet tulkitaan 100:ksi.

        vasenNopeus = 100;

      oikeaNopeus = channelEteenTaakse - channelOikealleVasemmalle;

    }else{

      vasenNopeus = channelEteenTaakse + channelOikealleVasemmalle;

      oikeaNopeus = sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(oikeaNopeus > 100)

        oikeaNopeus = 100;

    }

  }else{

     if(channelOikealleVasemmalle >= 0){

      vasenNopeus = channelEteenTaakse + channelOikealleVasemmalle;

      oikeaNopeus = -1*sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(oikeaNopeus < -100)

        oikeaNopeus = -100;


     }else{

      vasenNopeus = -1*sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(vasenNopeus < -100)

        vasenNopeus = -100;


      oikeaNopeus = channelEteenTaakse - channelOikealleVasemmalle;

     }
  }

  setMotorSpeed(leftMotor,  vasenNopeus);

	setMotorSpeed(rightMotor, oikeaNopeus);

	displayTextLine(1, "%s%d", "Vasen moottori: ", vasenNopeus);  // Testivaiheessa oli hyva nahda moottoreiden
  																														  // nopeudet naytolla, ja muutankaan siita ei
	displayTextLine(3, "%s%d", "Oikea moottori: ", oikeaNopeus);  // ole haittaa.

}
