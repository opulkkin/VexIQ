#pragma config(StandardModel, "Autobot IQ")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



// Olli Pulkkinen 20.5.2016

/* Ohjelmassa esiintyvan automaattiohjauksen toimintaidea on seuraava:

  1. Ajetaan suoraan, kunnes havaitaan distance sensorilla este joka on 15 cm paassa tai lahempana, MAXETEENAJOAIKA
     (= 15s nyt) tulee tayteen tai jomman kumman moottorin virta milliampeereina ylitta rajan MAXVIRTAETEENAJETTAESSA
     (= 400 mA nyt). Jos havaitaan este edessa distance sensorilla, mennaan kohtaan 2. Jos MAXETEENAJOAIKA tulee tayteen
     tai jomman kumman moottorin virta ylittaa rajan MAXVIRTAETEENAJETTAESSA, mennaan kohtaan 3.

  2. Kaantyminen. Ensin "arvotaan" suunta, johon kaantymista yritetaan ensimmaisena. Kaannytaan aina gyron avulla astemaara
     KAANTYMISKULMA, joka on lahella 90 astetta. Jos kummankaan moottorin virta ei ylita kaannyttaessa rajaa
     MAXVIRTAKAANNYTTAESSA(500 mA nyt) ja kaantyminen onnistuu ajassa MAXKAANTYMISAIKA(= 5s nyt), niin jatketaan kohtaan 1.
     Muussa tapauksessa(kaantyminen ei ole onnistunut ensimmaiseen suuntaan) yritetaan kaantya vastaavasti toiseen suuntaan
     KAANTYMISKULMA verran alkuperaisesta suunnasta, josta kaantymista ensimmaisena yritettiin. Jos tama onnistuu, mennaan
     kohtaan 1 ja jos ei onnistu, mennaan kohtaan 3.

  3. Peruutus. Peruutetaan jonkin aikaa. Jos peruutus onnistuu, eli puskurikytkimiin ei tule osumaa, eika kummankaan
     moottorin virta mene peruutuksen aikana rajan MAXVIRTAPERUUTETTAESSA(= 600 mA nyt) yli, mennaan kohtaan 2.
     Jos taas peruutus ei onnistu, eli tulee puskuriosuma tai jomman kumman moottorin virta menee rajan
     MAXVIRTAPERUUTETTAESSA yli, niin saatetaan menna kohtaa 1 tai kohtaan 2. Se kumpaan kohtaan mennaan ratkaistaan
     "arpomalla".

   Lisaksi mukana on kolme erilaista RC-ohjelmaa, joita voi valita ohjaimen E- ja F- napeilla. BtnFUp laittaa automaatin
   paalle, erilaiset RC-ohelmat voidaan valita napeilla BtnFDown, BtnEDown ja BtnEUp. RC- ohjelmat ovat perus tankkiohjaus,
   ja kaksi eri versiota muunnellusta arcade control-ohjauksesta(ks. MuunneltuArcadeControl.c-kooditiedosto, jossa taman
   ohjausmenetelman ideoista on selitetty ainakin jotain).

*/

#define MOOTTORIENNOPEUS 50

#define MAXETEENAJOAIKA 15000

#define MAXKAANTYMISAIKA 5000

#define KAANTYMISKULMA 88

#define MAXVIRTAETEENAJETTAESSA 300 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 400 luvun 300 tilalle.
                                    //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                    //alustalla(esim. ulkona nurmikolla).

#define MAXVIRTAKAANNYTTAESSA 400 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 500 luvun 400 tilalle
                                  //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                  //alustalla(esim. ulkona nurmikolla).


#define MAXVIRTAPERUUTETTAESSA 500 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 600 luvun 500 tilalle
																	 //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                   //alustalla(esim. ulkona nurmikolla).


#define PYSAYTYSRAJA 14


enum en_suunta{    // Maaritellaan enumin avulla uusi tyyppi en_suunta. Tata tyyppia oleva muuttuja voi pitaa
	                 // sisallaan kahta eri arvoa, ja naille arvoille on maaritelty tassa nimet OIKEA ja VASEN.
   OIKEA,

   VASEN

};

enum en_ohjaustyyppi{    // Maaritellaan enumin avulla uusi tyyppi en_ohjaustyyppi.

   AUTO,

   TANKKI,

   ARCADE1STICK,

   ARCADE2STICKS

};


// main-funktiossa(ja taskeissa) kaytettyjen funktioiden prototyypit ovat seuraavassa. Osaa naista funktioista
// kaytetaan myos muissa funktioissa.

void ajaEteenpain(void);

bool yritaKaantya(enum en_suunta ekaSuunta);

bool yritaPeruuttaa(void);

void pysayta(void);

bool etsiEstettaEdesta(void);

bool testaaYlikuormitus(float ylikuormitusraja);

bool arvoKaannytaanko(void);

enum en_suunta arvoKaantymisSuunta(void);

void asetaMoottorienNopeudet(short channelEteenTaakse, short channelOikealleVasemmalle);

// Automaattiohjauksen koodi seuraavassa:

task Automaatti(){


  clearTimer(T1);                   // Nollataan ajastin T1.

  clearTimer(T2);                   // Nollataan ajastin T1.

  clearTimer(T3);                   // Nollataan ajastin T1.


  bool kaantyminen;                 // muuttuja, jonka avulla hoidetaan se yritetaanko kaantaa robotti tietyssa osassa
                                    // ohjelmaa vai jatketaanko siita seuraavaksi suoraan.

  bool kaantyminenOnnistui;


  enum en_suunta kaantymisSuunta;   // Luodaan nyt muuttuja kaantymisSuunta, jonka tyyppi on ylla maaritelty
                                    // en_suunta. Jos on paatetty kaantya, niin arvotaan kaantymissuunta ja
                                    // laitetaan tulos ylos tahan muuttujaan.

  bool esteEdessa;                  // Tassa muuttujassa pidetaan tieto siita onko estetta edessa vai ei.
                                    // Arvo voi muuttua ainoastaan eteenpain ajettaessa.


  bool esteTakana = false;   // Tassa muuttujassa pidetaan tieto siita onko estetta takana vai ei.
                             // Arvo voi muutttua trueksi ainoastaan peruutettaessa.

	bool ylikuormitus; // Tassa muuttujassa pidetaan tieto siita onko moottoriylikuormitusta vai ei.

	short ajoAika;         // Muuttuja, jossa pidetaan muistissa tietyssa ohjelman osassa kulunutta aikaa.


  while(true)     // Ikuinen silmukka
	{

	  pysayta();

	  esteEdessa = etsiEstettaEdesta();

	  kaantyminen = true;

		kaantyminenOnnistui = true;

		ylikuormitus = false;

		ajoAika = 0;

		clearTimer(T1);                   // Nollataan ajastin T1.

	  // Ajetaan alussa eteenpain niin pitkaan kunnes este tulee eteen, moottoreissa tulee likaa rasitusta tai
	  // MAXETEENAJOAIKA tulee tayteen.

	  while (esteEdessa == false && ylikuormitus == false && ajoAika <= MAXETEENAJOAIKA){

	     ajaEteenpain();

	     esteEdessa = etsiEstettaEdesta();

	     ylikuormitus = testaaYlikuormitus(MAXVIRTAETEENAJETTAESSA);

	     ajoAika = time1[T1];

	  }

	  pysayta();


	  do{

    	// Nyt tiedetaan etta tassa vaiheessa vahintaan yksi ylla olevan while silmukan ehdoista ei ole enaa voimassa.
    	// Jos on tullut vastaan ylikuormitustilanne tai MAXETEENAJOAIKA on tullut tayteen, niin ainakin pienessa
	  	// huoneessa ajettaessa on syyta olettaa, etta robotti on jaanyt jumiin johonkin. Talloin kannattaa ottaa hieman
    	// peruutusta ensin ja yrittaa kaantymista vasta sen jalkeen, jos peruutus onnistuu.


	  	if(ylikuormitus == true || ajoAika > MAXETEENAJOAIKA || kaantyminenOnnistui == false){

	 	    esteTakana = yritaPeruuttaa();  // Palauttaa truen, jos peruuttaminen ei onnistu kunnolla.
	  																	  // Jos peruutus onnistuu, palauttaa falsen.
	 	 	}

	 		pysayta();

	  	// Jos ylla oleva if-lauseke suoritettiin ja takana oli este, niin arvotaan lahdetaanko seuraavaksi kaantymaan
	  	// vai mennaanko ohjelman alkuun. Jos ylla olevaa if-lauseketta ei suoritettu tai se suoritettiin mutta takana
	  	// ei ollut estetta, mennaan aina kaantymiseen.

	 	 if(esteTakana == true){

	 	    kaantyminen = arvoKaannytaanko();

	 	    esteTakana = false;

	 	 }

	 	 // Jos kaantyminen-muuttujan arvo on true, yritetaan seuraavaksi kaantymista


	 	 if(kaantyminen == true){

	   	 kaantymisSuunta = arvoKaantymisSuunta();

	   	 kaantyminenOnnistui = yritaKaantya(kaantymisSuunta);

	   	 pysayta();

	 	 }else{

	 	   kaantyminenOnnistui = true;   // Jos ei edes ole yritetty kaantya, niin laitetaan trueksi.

	 	 }


		}while(kaantyminenOnnistui == false);

	}

}

// Ensimmainen (muunneltu) arcade control -ohjaus, pelkastaan oikean puoleinen ohjaussauva kaytossa.

task Arcade1(){

  short kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema;


  while(true)     // Ikuinen silmukka
	{

	  kanavaEteenTaakseLukema = getJoystickValue(ChD);

  	kanavaOikealleVasemmalleLukema = getJoystickValue(ChC);


	  // Jos vahintaan toselta kanavalta tuleva getJoystickValue on itseisarvoltaan PYSAYTYSRAJAa suurempi
	  // niin talloin robotin moottoreille annetaan nopeudet asetaMoottorienNopeudet-funktion mukaisesti.

	  if(abs(kanavaEteenTaakseLukema) > PYSAYTYSRAJA || abs(kanavaOikealleVasemmalleLukema) > PYSAYTYSRAJA){

	    asetaMoottorienNopeudet(kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema);

		}else{

			setMotorSpeed(leftMotor, 0);    // Jos kumpikaan getJoystickValue arvoista ei ole itseisarvoltaan pysaytysrajaa suurempi
																			// niin pysaytetaan.
			setMotorSpeed(rightMotor, 0);

	  }

	}

}


// Toinen (muunneltu) arcade control -ohjaus, vasen ja oikea ohjaussauva ovat kaytossa.

task Arcade2(){

  short kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema;


  while(true)     // Ikuinen silmukka
	{

	  kanavaEteenTaakseLukema = getJoystickValue(ChA);

  	kanavaOikealleVasemmalleLukema = getJoystickValue(ChC);


	  // Jos vahintaan toselta kanavalta tuleva getJoystickValue on itseisarvoltaan PYSAYTYSRAJAa suurempi
	  // niin talloin robotin moottoreille annetaan nopeudet asetaMoottorienNopeudet-funktion mukaisesti.

	  if(abs(kanavaEteenTaakseLukema) > PYSAYTYSRAJA || abs(kanavaOikealleVasemmalleLukema) > PYSAYTYSRAJA){

	    asetaMoottorienNopeudet(kanavaEteenTaakseLukema, kanavaOikealleVasemmalleLukema);

		}else{

			setMotorSpeed(leftMotor, 0);    // Jos kumpikaan getJoystickValue arvoista ei ole itseisarvoltaan pysaytysrajaa suurempi
																			// niin pysaytetaan.
			setMotorSpeed(rightMotor, 0);

	  }

	}

}


// Tankkiohjauksen koodi:

task Tank(){

  while(true)     // Ikuinen silmukka
	{

	  // Jos vahintaan toinen getJoystickValue-arvoista on PYSAYTYSRAJAa suurempi
	  // niin talloin robotin moottoreille annetaan nopeudet normaalin tankdrive -ohjauksen mukaisesti.

	  if(abs(getJoystickValue(ChA)) > PYSAYTYSRAJA || abs(getJoystickValue(ChD)) > PYSAYTYSRAJA){

			setMotorSpeed(leftMotor,  (getJoystickValue(ChA)));
																																										                                       // Nama ovat aina valilla -100...100
			setMotorSpeed(rightMotor, (getJoystickValue(ChD)));

		}else{

			setMotorSpeed(leftMotor, 0);    // Jos kumpikaan getJoystickValue-arvoista ei ole itseisarvoltaan pysaytysrajaa
																			// suurempi niin pysaytetaan.
			setMotorSpeed(rightMotor, 0);

		}

	}

}



// main-funktio alkaa tasta:

task main(){


  setMotorBrakeMode(leftMotor, motorCoast);     // Robottia on helpompi siirreella lykkaamalla
  setMotorBrakeMode(rightMotor, motorCoast);    // talla asetuksella. Automaattiohjelmassa ihan sama
  																							// mika asetus tassa on.

  srand(nSysTime);  // generate seed for rand()


  enum en_ohjaustyyppi ohjaus = AUTO;

  short indeksi;

  for(indeksi = 5; indeksi > 0; indeksi--){  // Tauko, jotta gyro saa rauhassa kalibroitua.

     displayCenteredTextLine(2, "%d", indeksi);

     sleep(1000);

  }

  displayCenteredTextLine(2, "Automaatti");

  sleep(200);

  startTask(Automaatti);

  setTouchLEDColor(touchLED, colorGreen);



  // Seuraavassa ikuisessa silmukassa luetaan RC-ohjaimen nappien painalluksia ja aloitetaan ja lopetetaan
  // tiettyja taskeja sen mukaan mita on painettu.
  // Nyt ohjelmassa on viisi eri taskia(main, Automaatti, Arcade1, Arcade2 ja Tank) ja kun yritettiin
  // lisata kuudes task, niin se jatettiin huomioimatta. Siis eri taskien maksimimaara nayttaisi olevan 5.

  while(true){

    updateMotorPWMScale(leftMotor);  // Pyrkii pitamaan moottorien pyorimisnopeudet vakiona
                                     // vaikka akun jannite laskee.
	  updateMotorPWMScale(rightMotor);


    if(getJoystickValue(BtnEUp) == 1 && getJoystickValue(BtnEDown) == 0 && getJoystickValue(BtnFUp) == 0 && getJoystickValue(BtnFDown) == 0){

       if(ohjaus != ARCADE2STICKS){

          stopTask(Automaatti);

          stopTask(Arcade1);

          stopTask(Tank);

          pysayta();

          startTask(Arcade2);

          setTouchLEDColor(touchLED, colorViolet);

          displayCenteredTextLine(2, "Arcade 2");

       }

       ohjaus = ARCADE2STICKS;

    }else if(getJoystickValue(BtnEUp) == 0 && getJoystickValue(BtnEDown) == 1 && getJoystickValue(BtnFUp) == 0 && getJoystickValue(BtnFDown) == 0){

       if(ohjaus != ARCADE1STICK){

          stopTask(Automaatti);

          stopTask(Arcade2);

          stopTask(Tank);

          pysayta();

          startTask(Arcade1);

          setTouchLEDColor(touchLED, colorOrange);

          displayCenteredTextLine(2, "Arcade 1");

       }

       ohjaus = ARCADE1STICK;

    }else if(getJoystickValue(BtnEUp) == 0 && getJoystickValue(BtnEDown) == 0 && getJoystickValue(BtnFUp) == 1 && getJoystickValue(BtnFDown) == 0){

       if(ohjaus != AUTO){

          stopTask(Arcade1);

          stopTask(Arcade2);

          stopTask(Tank);

          pysayta();

          startTask(Automaatti);

          setTouchLEDColor(touchLED, colorGreen);

          displayCenteredTextLine(2, "Automaatti");

       }

       ohjaus = AUTO;

    }else if(getJoystickValue(BtnEUp) == 0 && getJoystickValue(BtnEDown) == 0 && getJoystickValue(BtnFUp) == 0 && getJoystickValue(BtnFDown) == 1){

       if(ohjaus != TANKKI){

          stopTask(Automaatti);

          stopTask(Arcade1);

          stopTask(Arcade2);

          pysayta();

          startTask(Tank);

          setTouchLEDColor(touchLED, colorBlueGreen);

          displayCenteredTextLine(2, "Tankkiohjaus");

       }

       ohjaus = TANKKI;

    }


    sleep(50);

  }

}



void ajaEteenpain(void){

  setMotorSpeed(leftMotor, MOOTTORIENNOPEUS);

  setMotorSpeed(rightMotor, MOOTTORIENNOPEUS);

  sleep(200);


}

void pysayta(void){

  setMotorSpeed(leftMotor, 0);

  setMotorSpeed(rightMotor, 0);

}


bool yritaKaantya(enum en_suunta ekaSuunta){

  bool onnistui = true;

  resetGyro(gyroSensor);

  clearTimer(T2);

  switch (ekaSuunta){

  case VASEN:

    setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS/2);

    setMotorSpeed(rightMotor, MOOTTORIENNOPEUS/2);

    sleep(300);

    while(getGyroDegrees(gyroSensor) < KAANTYMISKULMA){

    	 if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

    	     clearTimer(T2);

       		 setMotorSpeed(leftMotor, MOOTTORIENNOPEUS/2);

           setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS/2);

        	 sleep(300);

        	 while(getGyroDegrees(gyroSensor) > -1*KAANTYMISKULMA){

        	    if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

        	       onnistui = false;

        	       break;

        	    }

        	    sleep(50);

           }

           break;

       }

       sleep(50);

    }

    pysayta();

    break;

  case OIKEA:

    setMotorSpeed(leftMotor, MOOTTORIENNOPEUS/2);

    setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS/2);

    sleep(300);

    while(getGyroDegrees(gyroSensor) > -1*KAANTYMISKULMA){

    	 if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

    	     clearTimer(T2);

       		 setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS/2);

           setMotorSpeed(rightMotor, MOOTTORIENNOPEUS/2);

        	 sleep(300);

        	 while(getGyroDegrees(gyroSensor) < KAANTYMISKULMA){

        	    if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

        	       onnistui = false;

        	       break;

        	    }

        	    sleep(50);

           }

           break;

       }

       sleep(50);

    }

    pysayta();

    break;

  }

  return onnistui;

}

bool yritaPeruuttaa(void){

  bool esteOnTakana = false;

  byte laskuri = 0;

  setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS);

  setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS);

  sleep(500);

  for (laskuri = 0; laskuri < 20; laskuri++){

     if(testaaYlikuormitus(MAXVIRTAPERUUTETTAESSA) == true || getBumperValue(bumpSwitchLeft) == 1 || getBumperValue(bumpSwitchRight) == 1){

        esteOnTakana = true;

        setMotorSpeed(leftMotor, MOOTTORIENNOPEUS);

        setMotorSpeed(rightMotor, MOOTTORIENNOPEUS);

        sleep(300);

        break;

     }

     sleep(50);

  }


  pysayta();

  return esteOnTakana;

}


// Testaa onko estetta edessa. Palauttaa truen jos este on edessa, muuten palauttaa false.

bool etsiEstettaEdesta(void){

  short esteenEtaisyys = getDistanceValue(distanceMM);

  if(esteenEtaisyys <= 150)

     return true;

  else

     return false;

}

bool testaaYlikuormitus(float ylikuormitusraja){

  bool ylikuormitusta = false;

  if(getMotorCurrent(leftMotor) > ylikuormitusraja || getMotorCurrent(rightMotor) > ylikuormitusraja)

     ylikuormitusta = true;

  return ylikuormitusta;

}


bool arvoKaannytaanko(void){

   bool kaannytaan;

   short aputulos;

   aputulos = (rand() + time1[T1] + time1[T3]) % 2;

   switch (aputulos){

   case 0:

     kaannytaan = true;

     break;

   case 1:

     kaannytaan = false;

     break;
   }

   return kaannytaan;

}

enum en_suunta arvoKaantymisSuunta(void){

   enum en_suunta arvottuSuunta;

   short aputulos;

   aputulos = rand()%2;

   switch (aputulos){

   case 0:

     arvottuSuunta = VASEN;

     break;

   case 1:

     arvottuSuunta = OIKEA;

     break;
   }


   return arvottuSuunta;

}


// Tassa on asetaMoottorienNopeudet-funktion toteutus, tata kaytetaan siis arcade control-ohjauksissa.

void asetaMoottorienNopeudet(short channelEteenTaakse, short channelOikealleVasemmalle){

  short vasenNopeus = 0;

  short oikeaNopeus = 0;

  if(channelEteenTaakse >= 0){

    if(channelOikealleVasemmalle >= 0){

      vasenNopeus = sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(vasenNopeus > 100)   // Tata ei olisi pakko tehda koska yli sadan menevat nopeudet tulkitaan 100:ksi.

        vasenNopeus = 100;

      oikeaNopeus = channelEteenTaakse - channelOikealleVasemmalle;

    }else{

      vasenNopeus = channelEteenTaakse + channelOikealleVasemmalle;

      oikeaNopeus = sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(oikeaNopeus > 100)

        oikeaNopeus = 100;

    }

  }else{

     if(channelOikealleVasemmalle >= 0){

      vasenNopeus = channelEteenTaakse + channelOikealleVasemmalle;

      oikeaNopeus = -1*sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(oikeaNopeus < -100)

        oikeaNopeus = -100;


     }else{

      vasenNopeus = -1*sqrt(channelEteenTaakse*channelEteenTaakse + channelOikealleVasemmalle*channelOikealleVasemmalle);

      if(vasenNopeus < -100)

        vasenNopeus = -100;


      oikeaNopeus = channelEteenTaakse - channelOikealleVasemmalle;

     }
  }

  setMotorSpeed(leftMotor,  vasenNopeus);

	setMotorSpeed(rightMotor, oikeaNopeus);

}
