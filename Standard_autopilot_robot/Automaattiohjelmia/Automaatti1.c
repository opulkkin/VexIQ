#pragma config(StandardModel, "Autobot IQ")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



// Olli Pulkkinen 17.5.2016

/* Automaattiohjausohjelma AutobotIQ:lle. Ohjelman toiminta on seuraava:

  1. Ajetaan suoraan, kunnes havaitaan distance sensorilla este joka on 15 cm paassa tai lahempana, MAXETEENAJOAIKA
     (= 15s nyt) tulee tayteen tai jomman kumman moottorin virta milliampeereina ylitta rajan MAXVIRTAETEENAJETTAESSA
     (= 300 mA nyt). Jos havaitaan este edessa distance sensorilla, mennaan kohtaan 2. Jos MAXETEENAJOAIKA tulee tayteen
     tai jomman kumman moottorin virta ylittaa rajan MAXVIRTAETEENAJETTAESSA, mennaan kohtaan 3.

  2. Kaantyminen. Ensin "arvotaan" suunta, johon kaantymista yritetaan ensimmaisena. Kaannytaan aina gyron avulla astemaara
     KAANTYMISKULMA, joka on lahella 90 astetta. Jos kummankaan moottorin virta ei ylita kaannyttaessa rajaa
     MAXVIRTAKAANNYTTAESSA(400 mA nyt) ja kaantyminen onnistuu ajassa MAXKAANTYMISAIKA(= 5s nyt), niin jatketaan kohtaan 1.
     Muussa tapauksessa(kaantyminen ei ole onnistunut ensimmaiseen suuntaan) yritetaan kaantya vastaavasti toiseen suuntaan
     KAANTYMISKULMA verran alkuperaisesta suunnasta, josta kaantymista ensimmaisena yritettiin. Jos tama onnistuu, mennaan
     kohtaan 1 ja jos ei onnistu, mennaan kohtaan 3.

  3. Peruutus. Peruutetaan jonkin aikaa. Jos peruutus onnistuu, eli puskurikytkimiin ei tule osumaa, eika kummankaan
     moottorin virta mene peruutuksen aikana rajan MAXVIRTAPERUUTETTAESSA(= 500 mA nyt) yli, mennaan kohtaan 2.
     Jos taas peruutus ei onnistu, eli tulee puskuriosuma tai jomman kumman moottorin virta menee rajan
     MAXVIRTAPERUUTETTAESSA yli, niin saatetaan menna kohtaa 1 tai kohtaan 2. Se kumpaan kohtaan mennaan ratkaistaan
     "arpomalla".
*/

#define MOOTTORIENNOPEUS 50

#define MAXETEENAJOAIKA 15000

#define MAXKAANTYMISAIKA 5000

#define KAANTYMISKULMA 88

#define MAXVIRTAETEENAJETTAESSA 300 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 400 luvun 300 tilalle.
                                    //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                    //alustalla(esim. ulkona nurmikolla).

#define MAXVIRTAKAANNYTTAESSA 400 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 500 luvun 400 tilalle
                                  //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                  //alustalla(esim. ulkona nurmikolla).


#define MAXVIRTAPERUUTETTAESSA 500 //Isorenkaisen AutobotIQ:n tapauksessa kannattaa laittaa tahan 600 luvun 500 tilalle
																	 //Arvo kannattaa vaihtaa isommaksi myos esim. jos ohjelmaa kaytetaan raskaammalla
                                   //alustalla(esim. ulkona nurmikolla).


enum en_suunta{    // Maaritellaan enumin avulla uusi tyyppi en_suunta. Tata tyyppia oleva muuttuja voi pitaa
	                 // sisallaan kahta eri arvoa, ja naille arvoille on maaritelty tassa nimet OIKEA ja VASEN.
   OIKEA,

   VASEN

};


// main-funktiossa kaytettyjen funktioiden prototyypit ovat seuraavassa. Osaa naista funktioista kaytetaan myos muissa
// funktioissa kuin pelkastaan main-funktiossa.

void ajaEteenpain(void);

bool yritaKaantya(enum en_suunta ekaSuunta);

bool yritaPeruuttaa(void);

void pysayta(void);

bool etsiEstettaEdesta(void);

bool testaaYlikuormitus(float ylikuormitusraja);

bool arvoKaannytaanko(void);

enum en_suunta arvoKaantymisSuunta(void);



// main_funktio alkaa tasta:

task main()
{

  setMotorBrakeMode(leftMotor, motorCoast);     // Robottia on helpompi siirreella lykkaamalla
  setMotorBrakeMode(rightMotor, motorCoast);    // talla asetuksella. Automaattiohjelmassa ihan sama
  																							// mika asetus tassa on.


  srand(nSysTime);  // generate seed for rand()

  for(short i = 5; i > 0; i--){

     displayCenteredTextLine(2, "%d", i);

     sleep(1000);   // Tauko, jotta gyro saa rauhassa kalibroitua.

  }

  displayCenteredTextLine(2, "Automaatti");

  sleep(200);



  clearTimer(T1);                   // Nollataan ajastin T1.

  clearTimer(T2);                   // Nollataan ajastin T1.

  clearTimer(T3);                   // Nollataan ajastin T1.


  bool kaantyminen;                 // muuttuja, jonka avulla hoidetaan se yritetaanko kaantaa robotti tietyssa osassa
                                    // ohjelmaa vai jatketaanko siita seuraavaksi suoraan.

  bool kaantyminenOnnistui;


  enum en_suunta kaantymisSuunta;   // Luodaan nyt muuttuja kaantymisSuunta, jonka tyyppi on ylla maaritelty
                                    // en_suunta. Jos on paatetty kaantya, niin arvotaan kaantymissuunta ja
                                    // laitetaan tulos ylos tahan muuttujaan.

  bool esteEdessa;                  // Tassa muuttujassa pidetaan tieto siita onko estetta edessa vai ei.
                                    // Arvo voi muuttua ainoastaan eteenpain ajettaessa.


  bool esteTakana = false;   // Tassa muuttujassa pidetaan tieto siita onko estetta takana vai ei.
                             // Arvo voi muutttua trueksi ainoastaan peruutettaessa.

	bool ylikuormitus; // Tassa muuttujassa pidetaan tieto siita onko moottoriylikuormitusta vai ei.

	short ajoAika;         // Muuttuja, jossa pidetaan muistissa tietyssa ohjelman osassa kulunutta aikaa.



  while(true)     // Ikuinen silmukka
	{


	// Jos haluaa tulostaa akun jannitteen(milliampeereina) naytolle se onnistuu seuraavalla:
	//  displayCenteredTextLine(2, "%d", nImmediateBatteryLevel);

	  updateMotorPWMScale(leftMotor);  // Pyrkii pitamaan moottorien pyorimisnopeudet vakiona
                                     // vaikka akun jannite laskee.
	  updateMotorPWMScale(rightMotor);

	  pysayta();

	  esteEdessa = etsiEstettaEdesta();

	  kaantyminen = true;

		kaantyminenOnnistui = true;

		ylikuormitus = false;

		ajoAika = 0;

		clearTimer(T1);                   // Nollataan ajastin T1.

	  // Ajetaan alussa eteenpain niin pitkaan kunnes este tulee eteen, moottoreissa tulee likaa rasitusta tai
	  // MAXETEENAJOAIKA tulee tayteen.

	  while (esteEdessa == false && ylikuormitus == false && ajoAika <= MAXETEENAJOAIKA){

	     ajaEteenpain();

	     esteEdessa = etsiEstettaEdesta();

	     ylikuormitus = testaaYlikuormitus(MAXVIRTAETEENAJETTAESSA);

	     ajoAika = time1[T1];

	  }

	  pysayta();


	  do{

    	// Nyt tiedetaan etta tassa vaiheessa vahintaan yksi ylla olevan while silmukan ehdoista ei ole enaa voimassa.
    	// Jos on tullut vastaan ylikuormitustilanne tai MAXETEENAJOAIKA on tullut tayteen, niin ainakin pienessa
	  	// huoneessa ajettaessa on syyta olettaa, etta robotti on jaanyt jumiin johonkin. Talloin kannattaa ottaa hieman
    	// peruutusta ensin ja yrittaa kaantymista vasta sen jalkeen, jos peruutus onnistuu.


	  	if(ylikuormitus == true || ajoAika > MAXETEENAJOAIKA || kaantyminenOnnistui == false){

	 	    esteTakana = yritaPeruuttaa();  // Palauttaa truen, jos peruuttaminen ei onnistu kunnolla.
	  																	  // Jos peruutus onnistuu, palauttaa falsen.
	 	 	}

	 		pysayta();

	  	// Jos ylla oleva if-lauseke suoritettiin ja takana oli este, niin arvotaan lahdetaanko seuraavaksi kaantymaan
	  	// vai mennaanko ohjelman alkuun. Jos ylla olevaa if-lauseketta ei suoritettu tai se suoritettiin mutta takana
	  	// ei ollut estetta, mennaan aina kaantymiseen.

	 	 if(esteTakana == true){

	 	    kaantyminen = arvoKaannytaanko();

	 	    esteTakana = false;

	 	 }

	 	 // Jos kaantyminen-muuttujan arvo on true, yritetaan seuraavaksi kaantymista


	 	 if(kaantyminen == true){

	   	 kaantymisSuunta = arvoKaantymisSuunta();

	   	 kaantyminenOnnistui = yritaKaantya(kaantymisSuunta);

	   	 pysayta();

	 	 }else{

	 	   kaantyminenOnnistui = true;   // Jos ei edes ole yritetty kaantya, niin laitetaan trueksi.

	 	 }


		}while(kaantyminenOnnistui == false);

	}

}



void ajaEteenpain(void){

  setMotorSpeed(leftMotor, MOOTTORIENNOPEUS);

  setMotorSpeed(rightMotor, MOOTTORIENNOPEUS);

  sleep(200);


}

void pysayta(void){

  setMotorSpeed(leftMotor, 0);

  setMotorSpeed(rightMotor, 0);

}



bool yritaKaantya(enum en_suunta ekaSuunta){

  bool onnistui = true;

  resetGyro(gyroSensor);

  clearTimer(T2);

  switch (ekaSuunta){

  case VASEN:

    setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS/2);

    setMotorSpeed(rightMotor, MOOTTORIENNOPEUS/2);

    sleep(300);

    while(getGyroDegrees(gyroSensor) < KAANTYMISKULMA){

    	 if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

    	     clearTimer(T2);

       		 setMotorSpeed(leftMotor, MOOTTORIENNOPEUS/2);

           setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS/2);

        	 sleep(300);

        	 while(getGyroDegrees(gyroSensor) > -1*KAANTYMISKULMA){

        	    if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

        	       onnistui = false;

        	       break;

        	    }

        	    sleep(50);

           }

           break;

       }

       sleep(50);

    }

    pysayta();

    break;

  case OIKEA:

    setMotorSpeed(leftMotor, MOOTTORIENNOPEUS/2);

    setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS/2);

    sleep(300);

    while(getGyroDegrees(gyroSensor) > -1*KAANTYMISKULMA){

    	 if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

    	     clearTimer(T2);

       		 setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS/2);

           setMotorSpeed(rightMotor, MOOTTORIENNOPEUS/2);

        	 sleep(300);

        	 while(getGyroDegrees(gyroSensor) < KAANTYMISKULMA){

        	    if(testaaYlikuormitus(MAXVIRTAKAANNYTTAESSA) == true || time1[T2] > MAXKAANTYMISAIKA){

        	       onnistui = false;

        	       break;

        	    }

        	    sleep(50);

           }

           break;

       }

       sleep(50);

    }

    pysayta();

    break;

  }

  return onnistui;

}

bool yritaPeruuttaa(void){

  bool esteOnTakana = false;

  byte laskuri = 0;

  setMotorSpeed(leftMotor, -1*MOOTTORIENNOPEUS);

  setMotorSpeed(rightMotor, -1*MOOTTORIENNOPEUS);

  sleep(500);

  for (laskuri = 0; laskuri < 20; laskuri++){

     if(testaaYlikuormitus(MAXVIRTAPERUUTETTAESSA) == true || getBumperValue(bumpSwitchLeft) == 1 || getBumperValue(bumpSwitchRight) == 1){

        esteOnTakana = true;

        setMotorSpeed(leftMotor, MOOTTORIENNOPEUS);

        setMotorSpeed(rightMotor, MOOTTORIENNOPEUS);

        sleep(300);

        break;

     }

     sleep(50);

  }


  pysayta();

  return esteOnTakana;

}


// Testaa onko estetta edessa. Palauttaa truen jos este  on edessa, muuten palauttaa false.

bool etsiEstettaEdesta(void){

  short esteenEtaisyys = getDistanceValue(distanceMM);

  if(esteenEtaisyys <= 150)

     return true;

  else

     return false;

}

bool testaaYlikuormitus(float ylikuormitusraja){

  bool ylikuormitusta = false;

  if(getMotorCurrent(leftMotor) > ylikuormitusraja || getMotorCurrent(rightMotor) > ylikuormitusraja)

     ylikuormitusta = true;

  return ylikuormitusta;

}


bool arvoKaannytaanko(void){

   bool kaannytaan;

   short aputulos;

   aputulos = (rand() + time1[T1] + time1[T3]) % 2;

   switch (aputulos){

   case 0:

     kaannytaan = true;

     break;

   case 1:

     kaannytaan = false;

     break;
   }

   return kaannytaan;

}

enum en_suunta arvoKaantymisSuunta(void){

   enum en_suunta arvottuSuunta;

   short aputulos;

   aputulos = rand()%2;

   switch (aputulos){

   case 0:

     arvottuSuunta = VASEN;

     break;

   case 1:

     arvottuSuunta = OIKEA;

     break;
   }


   return arvottuSuunta;

}
